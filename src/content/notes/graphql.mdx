---
title: GraphQL
tags: ["graphql"]
---

# GraphQL

Learned from howtographql.com (Which seems to be created by prisma.io)

## What is GraphQL

- Declarative data fetching
- Single Endpoint

REST was fine for when applications were simpler and development times weren't as fast.

GraphQL minimizes the amount of data getting transferred because you're only asking for what you need. This makes your apps faster.

It's hard for a REST endpoint to suit itself well to many different frontends.

The way that REST APIs need to be continually modified to account for different requirements slows down production time. Instead of having to wait for your backend to update to handle the frontend needs, the frontend just changes their request.

## GraphQL is the better REST

REST endpoints result in under-fetching and over-fetching when you're calling for your data. Having worked on a production app with a REST endpoint, I know what this is like. We needed to hit several endpoints to flesh out a single page, and when the designs changed, I needed to get another developer to change the way the API worked, or open a new endpoint.

GraphQL uses 'resolver functions' to get the data. I'm assuming this will work similarly to Redux's or RxJS's resolvers.

GraphQL is strongly typed to define the capabilities of an API. Without this I doubt a lot of the filtering features would work.

Creating the typed schema up front allows for a sort of contract between the frontend and backend. This way the frontend can mock their data for testing while the backend is being created.

## GraphQL Core Concepts

GraphQL has a "Schema Definition Language" or SDL. This is where you define the types.

If there is an exclamation point following the type, it's required.

```graphql
type Person {
  name: String!
  age: Int!
}
```

Line breaks, not commas or semicolons, are what start the next value.

### Adding Relations

We can add related fields like this. Make sure you don't use a protected word for the name of your schema.

```graphql
type Person {
  name: String!
  age: Int!
  posts: [Post!]!
}
```

```graphql
type Post {
  title: String!
  author: Person!
}
```

### Fetching Data with Queries

```graphql
{
  allPersons {
    name
  }
}
```

Here the `allPersons` field is the _root_ of the query and everything that follows the root field is the _payload_.

You can specify params with parentheses after the field like this:

```graphql
{
  allPersons(last: 3) {
    name
  }
}
```

That `last` argument is specified in the schema.

### Writing Data with Mutations

With GraphQL we update data in the DB with _mutations_. I haven't done much of this because of the read-only nature of Gatsby's GraphQL, so this is new territory.

They follow the same syntax structure but start with the `mutation` keyword.

```graphql
mutation {
  createPerson(name: "Bob", age: 32) {
    name
    age
  }
}
```

`createPerson` is a root field. It takes two args that specify the name and age. The `name` and `age` part inside the query is just asking for the data back.

GraphQL Types have unique IDs generated by the server.

### Subscriptions

GraphQL has this amazing feature called Subscriptions that allows for live data streaming. You subscribe to an event and get updated with new data whenever the event fires.

This seems to be implementing websockets, and it's just amazing that you get this out of the box with GraphQL. This seems like it should solve some of the issues we're experiencing with making live previews and things for Static sites.

```graphql
subscription {
  newPerson {
    name
    age
  }
}
```

The client sends this subscription to the server, and the server knows to send that requested data along whenever the `newPerson` event fires.

This eliminates any need for polling. I'm wondering how fast this works. Would this be usable in a chat app, or is there too much latency?

### Writing an actual GraphQL Schema

The schema is one of the most important concepts when working with a GraphQL API. I like that the contractual nature of the schema makes things like GraphiQL possible. You know exactly what the data looks like, and you can use nice GUIs with it.

When writing a schema there are a couple special _root_ types. I'm familiar with Query, not Mutation or Subscription.

```graphql
type Query { ... }
type Mutation { ... }
type Subscription { ... }
```

We enable queries, mutations and subscriptions by defining them inside each of those types.

To define `allPersons` we do this:

```graphql
type Query {
  allPersons: [Person!]!
}
```

`allpersons` is an array of `Person` where everything's required.

In the example we queried for `last` to give us the most recent `Person` objects. We need to add that to the schema like this:

```graphql
type Query {
  allPersons(last: Int): [Person!]!
}
```

It's not required so no `!`. I'm not sure how we make the `last` argument functional. I'm assuming that comes later. Right now I'm guessing it wouldn't do anything.

For the mutations we define the arguments in the same way and point it to the type `Person`.

```graphql
type Mutation {
  createPerson(name: String!, age: Int!): Person!
}
```

The subscription is interesting:

```graphql
type Subscription {
  newPerson: Person!
}
```

I would have expected it to reference `createPerson`. I'm curious to see how we wire all these up. Does the `new` in `newPerson` automatically check for new instances of the `Person` type being created? If so that's pretty great.

### Creating full CRUD for this example

So the tutorial is going through and adding mutations for `updatePerson` and `deletePerson`, and it's making me think more that these words in front will be respected and act accordingly. The tutorial isn't saying one way or another, which I find a bit odd.

## Big Picture (Architecture)

GraphQL is only released as a spec. It's really just a long document that says how a GraphQL server should behave.

This is going to go through common architectural use cases

### 1. GraphQL with a connected database

Most common for _greenfield_ projects. This uses a single web server implementing GQL. The server then resolves those queries and creates the response with data it got from the database.

GQL is "Transport Layer Agnostic" which means it can be used with any network protocol. You can implement GQL based on TCP, Websockets, etc.

GQL is also "database agnostic" and takes SQL and noSQL DBs. (Graph Database? Not sure.)

### 2. GraphQL server integrating existing systems

For companies with legacy infrastructures and many different APIs. FOr this GraphQL can unify these systems and hide the complexity behind a nice GraphQL API.

New client applications can be developed that work with the GraphQL format. You can put Legacy Systems, Microservices and Third-Party APIs behind a GraphQL server to access them all through one protocol.

### 3. Hybrid approach with connected database & Integrated systems

This combines the first two systems. In the first the DB is connected directly to the GraphQL server. In the second the Server was separate and queried from existing systems.

In this method you can have a connected DB _and_ legacy or third party systems.

But how does it connect all these things?

### Resolver Functions

GraphQL uses resolver functions to make all this happen.

- GraphQL queries and mutations consist of a set of _fields_
- The GraphQL server has _one resolver function per field_
- The purpose of each resolver is to retrieve the data for its corresponding field.

#### Resolver Example

If we send this query:

```graphql
query {
  User(id: "er3tg4sa0frj") {
    name
    followers(first: 5) {
      name
      age
    }
  }
}
```

The resolvers we'll have to create to handle this type of query:

```graphql
User(id: String!): User
name(user: User!): String
age(user: User!): Int
friends(first: Int, user: User!): [User!]!
```

In this first line:

```graphql
User(id: String!): User
```

We keep the `User` optional/nullable because we don't know if that user exists.

### GraphQL Clients

GQL is great for Front end developers especially, because a lot of the complexity gets pushed to the backend where the servers can do the heavy lifting.

#### Imperative vs. Declarative data fetching

With REST APIs:

1. construct and send HTTP Request
2. receive and parse server response
3. store data locally
4. display information in the UI

With GraphQL:

1. describe data requirements (create the query)
2. Display the information in the UI

Everything inbetween should be handled by the GraphQL server.

---

Well that's it for the standard tutorial. At this point it lets you go to advanced topics or jump to the hands-on tutorial. I'm going to do the React + Apollo tutorial and come back to the advanced topics when I'm done with this and understand it a bit better.
